# -*- coding: utf-8 -*-
"""1804102_Apriori-Scratch.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pXILP7n8Jq66nSZ0pqaugoL9waal2NCF
"""

import pandas as pd
import numpy as np
from collections import Counter
from itertools import combinations

df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/store_data.csv', header = None)
df

df = df.fillna("Empty")

rows_as_list = df.values.tolist()
rows_as_list

type(rows_as_list[1][3])

data = []
for i in range(len(rows_as_list)) :
  row_num = i
  curr = []
  for j in rows_as_list[i] :
    if j != 'Empty' :
      curr.append(j) 
  data.append([row_num, curr]) 
data

support = float(input("Enter the Minimum Support Value in(%): "))
support = support / 100

conf = float(input("Enter the Minimum Confidence Value in(%): "))
support_count = int(support*len(data))

print(support_count)

def PrintAns(C_or_L, K, type) : 
  print(type + str(K) + ":")
  for item_set in C_or_L:
    cnt = C_or_L[item_set] 
    if K == 1 and type == 'C': 
      print(str([item_set]) + ": " + str(cnt))
    else:
      print(str(list(item_set)) + ": " + str(cnt))
  print()

def initialize(data) :
  unique = []
  for lst in data:
    for items in lst[1]:
      if(items not in unique):
        unique.append(items)
  unique = sorted(unique)
  print(unique)

  Candidate_Set = Counter()

  for items in unique:
    for transaction in data:
      if(items in transaction[1]):
        Candidate_Set[items]+=1

  PrintAns(Candidate_Set, 1, "C")

  frequent_item_set = Counter()

  for item_set in Candidate_Set:
    if(Candidate_Set[item_set] >= support_count):
      frequent_item_set[frozenset([item_set])] += Candidate_Set[item_set]
  return frequent_item_set

def Apriori_Scratch(data) :
  count = 1;
  while count <= 10000:
      
      if count == 1 :
        frequent_item_set = initialize(data)
        PrintAns(frequent_item_set, 1, "L")
        Previous_L = frequent_item_set
        Sequence = 1
        count += 1
        continue

      possible_candidate_set = set()
      Prev_L = list(Previous_L)

      for i in range(0,len(Prev_L)):
          for j in range(i + 1,len(Prev_L)):
              total = Prev_L[i].union(Prev_L[j])

              if(len(total) == count):
                  possible_candidate_set.add(Prev_L[i].union(Prev_L[j]))
      
      possible_candidate_set = list(possible_candidate_set)
      Candidate_Set = Counter()

      for item_set in possible_candidate_set:
          Candidate_Set[item_set] = 0
          for row in data:
              transaction = set(row[1])
              if(item_set.issubset(transaction)):
                  Candidate_Set[item_set]+=1

      PrintAns(Candidate_Set, count, "C")
      print()

      frequent_item_set = Counter()
      for item_set in Candidate_Set:
          if(Candidate_Set[item_set] >= support_count):
              frequent_item_set[item_set] += Candidate_Set[item_set]
    
      if(len(frequent_item_set) != 0):
        PrintAns(frequent_item_set, count, "L")
      else :
        print("This is the Final(frequent set)");
        PrintAns(Previous_L, Sequence, "L")
        break
      count += 1
      Previous_L = frequent_item_set
      Sequence = count

  return Previous_L, Sequence

Previous_L, Sequence = Apriori_Scratch(data)

def PrintRules(lst1, lst2, conf) : 

  for i in range(0, len(lst1)) : 
    curr = lst1[i];
    if(i == len(lst1) - 1) :
      print(curr, end = " ")
      print("----->", end = ' ')
    else :
      print(curr, end = ",")

  for i in range(0, len(lst2)) : 
    curr = lst2[i];
    print(curr, end = ", ")
    if(i == len(lst2) - 1) :
        print(curr, end = " ")
        print(": " + str(conf))
    else :
      print(curr, end = ",")

mapping = {}

for item_set in Previous_L:

    for r in range(1,len(item_set)):

        combination = []
        for i in combinations(item_set, r) : 
          combination.append(frozenset(i))
        
        
        for x in combination:
            y = item_set-x
            xy = item_set
            support_xy = support_x = support_y = 0
            for j in data:
                transaction = set(j[1])
                if(x.issubset(transaction)):
                    support_x += 1
                if(y.issubset(transaction)):
                    support_y += 1
                if(xy.issubset(transaction)):
                    support_xy += 1

            confidence_x = support_xy/support_x*100
            confidence_y = support_xy/support_y*100

            PrintRules(list(x), list(y), confidence_x)
            PrintRules(list(y), list(x), confidence_y)

            plus=["->"]
            merged_string = " ".join(list(x)+plus+list(y))
            mapping[merged_string]=confidence_x

            merged_string = " ".join(list(y)+plus+list(x))
            mapping[merged_string]=confidence_y
    print()

N=int(input("Enter a value N to find first N number of Association rules of Highest Confidence Value in(%) : "))
from itertools import islice
sorted_map = dict(sorted(mapping.items(), key=lambda x: x[1], reverse=True))

first_N_values = dict(islice(sorted_map.items(), N))

for key, value in first_N_values.items():
    formatted_value = "{:.2f}".format(value)
    print(f"Association Rule: [{key}], Confidence Score : {formatted_value}"+"%")